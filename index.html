<1a 2D Linear Convolution-->

clc;
x = [1,2,3;4,5,6;7,8,9];
h = [1;1;1];
disp(y,'Linear convolution result y=');
y = conv2(x,h);


<1b Circular Convolution between two 2D matrices-->

clc;
x=[1,2;3,4];
h=[5,6;7,8];
X=fft2(x);
H=fft2(h);
Y=X.*H;
y=ifft(Y);
disp(y,'Cicular Convolution Result Y=')

<2 Circular Convolution expressed as linear convolution plus alias>

clc;
x=[1,2;3,4];
h=[5,6;7,8];
y=conv2(x,h);
y1=[y(:,1)+y(:,$),y(:,2)];
y2=[y1(1,:)+y1($,:);y1(2,:)];
disp(y,'Linear Covolution result y=');
disp(y2,'Cicular Linear Convolution expressed as Linear convolution plus alias=');

<3a Linear Cross correlation of a 2D matrix>

clc;
x=[3,1;2,4];
h1=[1,5;2,3];
h2=h1(:,$:-1:1);
h=h2($:-1:1,:);
y=conv2(x,h)
disp(y,'Linear cross correlation of 2D matrix y=')    

<3b Circular correlation between two signals>

clc;
X=[1,5;2,4];
h=[3,2;4,1];
h2=h1(:,$:-1:1);
h3=h2($:-1:1,:);
X=fft2(x);
H=fft2(h3);
Y=X.*H;
y=ifft(Y);
disp(y,'Circular Correlation Result y=')    

<3c Linear auto correlation of a 2D matrix>

clc;
x1=[1,1;1,1];
x2=x1(:,$:-1:1);
x2=x2($:-1:1,:)
x=conv2(x1,x2)
disp(x,'Linear auto correlation result x=')  

<4 DFT of 4x4 gray scale image>

clc;
f=[1,1,1,1;1,1,1,1;1,1,1,1;1,1,1,1];
t=fft2(f);
disp(t,'display')    

<5a Compute discrete cosine transform>

clc;
N=[1,2,3,4]
x=dct(N);
disp(x,'DCt matrix of order four')    

<5b Program to perform KL transform for the given 2D matrix>

clc;
f=[1,1,1,1;1,1,1,1;1,1,1,1;1,1,1,1];
N=4
for k=0:N-1
for l=0:N-1
w(k+1,l+1)=int(cos((2*%pi*k*1)/N)-%i*sin((2*%pi*k*1)/N))
end
end
disp(w,'Kernel Matrix of 2D DFT=')
F=w*f*w 
disp(F,'2D DFT of given 2D image=')  

<6a Brightness Enhancement>

clc;
close;
a = imread(fullpath(getIPCVpath()+"/images/"+'baboon.png'));
[m,n] = size(a);
//t = input(Enter The Threshold Parameter);
for i = 1:m
for j = 1:n
b(i,j)=50+a(i,j);
end
end
figure(1)
imshow(a);
title('Original Image')
figure(2)
imshow(b);
title('Brightness Enhancement');

<6b Brightness Suprression of an image>

clc;
close;
a = imread(fullpath(getIPCVpath()+"/images/"+'baboon.png'));
[m,n] = size(a);
//t = input(Enter The Threshold Parameter);
for i = 1:m
for j = 1:n
b(i,j)=a(i,j)-50;
end
end
figure(1)
imshow(a);
title('Original Image')
figure(2)
imshow(b);
title('Brightness suprression of an image');

<6c Contrast Manipulation>

clc;
close;
a = imread(fullpath(getIPCVpath()+"/images/"+'baboon.png'));
[m,n] = size(a);
//t = input(Enter The Threshold Parameter);
for i = 1:m
for j = 1:n
b(i,j)=a(i,j)*1.5;
end
end
figure(1)
imshow(a);
title('Original Image')
figure(2)
imshow(b);
title('Contrast Manipulation of an image');

<6d Negative Image>
    
a = imread(fullpath(getIPCVpath()+"/images/"+'baboon.png'));
[m,n] = size(a);
//t = imput(Enter The Threshold Parameter);
for i = 1:m
for j = 1:n
b(i,j)=255-a(i,j);
end
end
figure(1)
imshow(a);
title('Original Image');
figure(2)
imshow(b);
title('Image Negative');

<7a Perform Threshold Operation>

a = imread(fullpath(getIPCVpath()+"/images/"+'baboon.png'));
a = rgb2gray(a);
[m, n] = size(a);
//t = input(Enter The Threshold Parameter);
for i = 1:m
for j = 1:n
if (a(i,j)<100)
b(i,j)=0;
else
b(i,j)= 255;
end
end
end
// Output Section
figure(1)
imshow(a);
title('Original Image');
figure(2)
imshow(b);
title('Threshold Image');

<7b Threshold image without background>

a = imread(fullpath(getIPCVpath()+"/images/"+'baboon.png'));
[m,n] = size(a);
//t = input('Enter The Threshold Parameter');
for i = 1:m
for j = 1:n
if (a(i,j)<100)
b(i,j)=0;
elseif (a (i,j)>200)
b(i,j)=0;
else
b(i,j)= 255;
end
end
end
// Output Section
figure(1)
imshow(a);
title('Original Image');
figure(2)
imshow(b);
title('Gray Level Slicing without preserving background');

<7c Threshold image with preserving background>

a = imread(fullpath(getIPCVpath()+"/images/"+'baboon.png'));
[m,n] = size(a);
//t = input(Enter The Threshold Parameter);
for i = 1:m
for j = 1:n
if (a(i,j)<100)
b(i,j)=0;
elseif (a (i,j)>200)
b(i,j)=a(i,j);
else
b(i,j)= 255;
end
end
end
// Output Section
figure(1)
imshow(a);
title('Original Image');
figure(2)
imshow(b);
title('Gray Level Slicing with preserving background');

<7d Perform image arithmetic operation>

clc;
close;
im1 = imread(fullpath(getIPCVpath() + "/images/baboon.png"));
im2 = imread(fullpath(getIPCVpath() + "/images/peppers.png"));
ima1 = imadd(im1, im2);
ima2 = imadd(im1, 150);
subplot(221);imshow(im1);title('First Image');
subplot(222);imshow(im2);title('Second Image');
subplot(223);imshow(ima1);title('First Image + Second Image');
subplot(224);imshow(ima2);title('First Image + constant*100');
ims1 = imsubtract(im1, im2);
ims2 = imsubtract(im1, 200);
scf();
subplot(221);imshow(im1);title('First Image');
subplot(222);imshow(im2);title('Second Image');
subplot(223);imshow(ims1);title('First Image - Second Image');
subplot(224);imshow(ims2);title('First Image - constant*100');
imm1 = immultiply(im1 , im2);
imm2 = immultiply(im1, 25);
scf();
subplot(221);imshow(im1);title('First Image');
subplot(222);imshow(im2);title('Second Image');
subplot(223);imshow(imm1);title('First Image * Second Image');
subplot(224);imshow(imm2);title('First Image * constant * 2');
imd1 = imdivide(im1 , im2);
imd2 = imdivide(im1, 0.05);
scf();
subplot(221);imshow(im1);title('First Image');
subplot(222);imshow(im2);title('Second Image');
subplot(223);imshow(imd1);title('First Image / Second Image');
subplot(224);imshow(imd2);title('First Image / constant / 0.2');
messagebox('thanks!' ,'End of the demo','info' , 'done' , 'model' );

<10a Histogram of Gray scale image and equalized image>

clc;
close;
function histplot(a)
a = double(a);
big= max(max(a));
[row col]= size(a);
c = row*col;
h= zeros(1,300);
z = zeros(1,300);
for n = 1:1:row
for m =1:1:col
if a(n,m)==0 then
a(n,m)=1;
end
end
end
for n = 1:1:row
for m = 1:1:col
t = a(n,m);
h(t)=h(t)+1;
end
end
figure(2);
bar(h);
title('Histogram of the Original Image');
endfunction
a = imread(fullpath(getIPCVpath() + "/images/Lena_dark.png"));
figure(1);
imshow(a);
title('Original Image');
histplot(a);
J = imhistequal(a);
figure(3);
imshow(J);
title('Equalized Image');
figure(4);
histplot(J);
title('Histogram of the Equalized Image');

<10b Histogram of colour image>

clc;
close;
a = imread(fullpath(getIPCVpath()+"/images/baboon.png"));
a = double(a);
big = max(max(a));
[row col]=size(a);
c = row * col;
h = zeros(1,300);
z = zeros(1,300);
for n = 1:1:row
for m = 1:1:col
if a(n,m) == 0 then
a(n,m) = 1;
end
end
end
for n = 1:1:row
for m = 1:1:col
t = a(n,m)
h(t) = h(t) + 1;
end
end
figure(1);
title('Original Image')
imshow(uint8(a));
figure(2);
title('Histogram of RGB image');
bar(h);

<10c Read an RGB image and extract the three colour components red green blue>

RGB = imread (fullpath(getIPCVpath()+ "/images/baboon.png"));
a1 = RGB;
b1 = RGB;
c1 = RGB;
a1 (: ,: ,1) = 0;
b1 (: ,: ,2) = 0;
c1 (: ,: ,3) = 0;
figure(1)
imshow(RGB);
figure(2)
imshow(a1);
figure(3)
imshow(b1);
figure(4)
imshow(c1);

<10d Read a color image and seperate the color image into red green and blue planes>

clc;
close;
im = imread(fullpath(getIPCVpath() + "/images/baboon.png"));
Red = im(: , : ,1);
Green = im(: ,: ,2);
Blue = im(: , : , 3);
// Get Histplot Value For Each Channel
[yRed, x] = imhist(Red);
[yGreen, x] = imhist(Green);
[yBlue, x] = imhist(Blue);
// plot them together in one plot
plot(x, yRed, 'Red' , x , yGreen, 'Green', x, yBlue, 'Blue' );
figure (1);
imshow(im);
title('Original Image');
figure(2);
bar(x, yRed, 'red');
title('Red Component');
figure(3);
bar(x, yGreen, 'green');
title('Green Component');
figure(4);
bar(x, yBlue, 'blue');
title('Blue Component');

<8a Differentiation of Gaussian function>

clc;
close;
sigma = input('Enter the value of sigma')
i= -10:.1:10;
j= -10:.1:10;
r=sqrt(i.*i+j.*j);
y=(1/(sigma^2))*(((r.*r)/sigma^2)-1).*exp(-r.*r/2*sigma^2);
plot(i,y)
legend(sprintf('The sigma value is % g',sigma))
xtitle('Differentiation of Gaussian function')    

<8b Shape of dog filter>

sigma1 =input(' Enter the value of sigma1 : ')
sigma2 =input(' Enter the value of sigma2 : ')
i= -10:.1:10;
j= -10:.1:10;
r=sqrt(i.*i+j.*j);
y1=(1/( sigma1 ^2))*(((r.*r)/sigma1 ^2) -1).*exp(-r.*r/2*sigma1 ^2);
y2=(1/( sigma2 ^2))*(((r.*r)/sigma2 ^2) -1).*exp(-r.*r/2*sigma2 ^2);
y=y1-y2;
plot(i,y)
xtitle('Shape of Dog filter')

<9a Binary image processing
    image dialtion
    image erosion
    image opening
    image closing>

clc;
close;
S = imread(fullpath(getIPCVpath()+"/images/morpex.png"));
figure(1)
imshow(S);
title("original image");
se=imcreatese("ellipse",5,5);
s2=imopen(S,se);
s3=imclose(S,se);
s4=imerode(S,se);
s5=imdilate(S,se);

figure(2)
subplot(2,2,1);
imshow(s2);
title("opening");

subplot(2,2,2);
imshow(s3);
title("closing");

subplot(2,2,3);
imshow(s4);
title("errosion");

subplot(2,2,4);
imshow(s5);
title("dialtion");